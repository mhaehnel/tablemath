\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{tablemath}[2017/12/08]
\RequirePackage{pgfplotstable}
\RequirePackage{pgfkeys}
\RequirePackage{pgfmath}
\RequirePackage{trace}

\ProcessOptions\relax
\newif\iftablemath@printresult
\newif\iftablemath@usefpu

\pgfkeys{
    /tablemath/.is family, 
    /tablemath,
        quantile/.is family,
        fun/.is family,
        column/.estore in = \tablemath@column, 
        show/.is if = tablemath@printresult,
        show/.default = true,
        show/.initial = true,
        show,
    /tablemath/quantile,
        q/.estore in = \tablemath@quantile@q,
        k/.estore in = \tablemath@quantile@k,
        upper quartile/.style={q=4,k=3},
        lower quartile/.style={q=4,k=1},
        median/.style={q=4,k=2},
        method/.estore in = \tablemath@quantile@method,
        method=7,
        .search also = {/tablemath},
    /tablemath/fun,
        initial/.estore in = \acc,
        use fpu/.is if = tablemath@usefpu,
        operation/.store in = \tablemath@fun@code,
        finally/.store in = \tablemath@fun@postcode,
        finally=\acc, 
        initial=0,
        sum/.style = {operation={\acc + \cell}},
        product/.style = {initial=1,operation={\acc * \cell}},
        average/.style = {sum,finally={\acc/\rows}},
        .search also = {/tablemath},
}
        
\def\tablemath@cmdname#1{\expandafter\@gobble\string#1}%

\newcommand{\tablemath@parseSorted}[1]{
        \tablemath@sort{\tablemath@column}{#1}
        %
        \newcommand\tablemath@tmp[1]{%
            %Find min in first fow
            \pgfplotstablegetelem{0}{\tablemath@column}\of{##1}%
            \expandafter\pgfmathsetmacro\csname tablemath@results@\tablemath@cmdname#1@Min@\tablemath@column\endcsname{\pgfplotsretval}%
            %Find max by looking in last row
            \pgfplotstablegetrowsof{##1}%
            \pgfmathtruncatemacro{\tmp}{\pgfmathresult-1}%
            \pgfplotstablegetelem{\tmp}{\tablemath@column}\of{##1}%
            \expandafter\pgfmathsetmacro\csname tablemath@results@\tablemath@cmdname#1@Max@\tablemath@column\endcsname{\pgfplotsretval}%
        }
        \expandafter\tablemath@tmp\expandafter{\tablemath@tmptable}
}

%Arguments: Column, Original Table name
\newcommand\tablemath@sort[2]{
    %Internal: Sort table #3 using col #2 and store in #1
    \newcommand\tablemath@sortAux[3]{%
        \pgfplotstablesort[sort cmp=float <,sort key=##2]{##1}{##3}
    }
    \newcommand\tablemath@alias[1]{\def\tablemath@tmptable{##1}}
    \ifcsname tablemath@results@sorted@\tablemath@cmdname#2@#1\endcsname
    \else
        \expandafter\tablemath@sortAux\expandafter{\csname tablemath@results@sorted@\tablemath@cmdname#2@#1\endcsname}{#1}{#2}
    \fi
    \expandafter\tablemath@alias\expandafter{\csname tablemath@results@sorted@\tablemath@cmdname#2@#1\endcsname}
}


\newcommand\tablemathQuantile[2][]{%
    \pgfkeys{/tablemath/quantile, #1}
    \ifnum\tablemath@quantile@q < 2\pgferror{Quantiles smaller than the 2-Quantile don't make sense}\fi
    \ifnum\tablemath@quantile@k < \tablemath@quantile@q\else\pgferror{Quantiles must have k < q [k=\tablemath@quantile@k, q=\tablemath@quantile@k]}\fi
    \ifnum\tablemath@quantile@k < 1\pgferror{The k-th q-Quantile must have k >= 1 [k=\tablemath@quantile@k]}\fi
    %Cache sorting ...
    \tablemath@sort{\tablemath@column}{#2}
    %Get quantile
    \expandafter\pgfplotstablegetrowsof\expandafter{\tablemath@tmptable}
    \pgfmathsetmacro{\tablemath@rows}{\pgfplotsretval}
    \newcommand\y[3]{%
        \pgfmathparse{int((##2)-1)}
        \pgfplotstablegetelem{\pgfmathresult}{\tablemath@column}\of{##1}
        \pgfmathsetmacro{##3}{\pgfplotsretval}
    }
    \pgfmathsetmacro{\tablemath@quantile@p}{\tablemath@quantile@k/\tablemath@quantile@q}
    %Select method, remember: p can not be 1 or 0 due to the above constraints
    \ifcase\tablemath@quantile@method%0
        \pgferror{Quantile method 0 invalid. Valid methods are 1-9}
    \or%1
        \pgfmathsetmacro{\h}{\tablemath@rows*\tablemath@quantile@p+0.5}
        \expandafter\y\tablemath@tmptable{ceil(\h-0.5)}{\tablemathretval}
    \or%2
        \pgfmathsetmacro{\h}{\tablemath@rows*\tablemath@quantile@p+0.5}
        \expandafter\y\tablemath@tmptable{ceil(\h-0.5)}{\xh}
        \expandafter\y\tablemath@tmptable{ceil(\h+0.5)}{\xhn}
        \pgfmathsetmacro{\tablemathretval}{(\xh+\xhn)/2}
    \or%3
        \pgfmathsetmacro{\h}{\tablemath@rows*\tablemath@quantile@p}
        \pgfmathparse{int(round(\h))}
        \ifnum\pgfmathresult=0
            \expandafter\y\tablemath@tmptable{1}{\tablemathretval}
        \else
            \expandafter\y\tablemath@tmptable{round(\h)}{\tablemathretval}
        \fi
    \or%4
        \pgfmathsetmacro{\h}{\tablemath@rows*\tablemath@quantile@p}
        \pgfmathparse{int(floor(\h))}
        \ifnum\pgfmathresult=0
            \expandafter\y\tablemath@tmptable{1}{\tablemathretval}
        \else
            \expandafter\y\tablemath@tmptable{floor(\h)}{\xh}
            \expandafter\y\tablemath@tmptable{floor(\h+1)}{\xhn}
            \pgfmathsetmacro{\tablemathretval}{\xh+(\h-floor(\h))*(\xhn-\xh)}
        \fi
    \or%5
        \pgfmathsetmacro{\h}{\tablemath@rows*\tablemath@quantile@p+0.5}
        \pgfmathparse{int(floor(\h))}
        \ifnum\pgfmathresult=0
            \expandafter\y\tablemath@tmptable{1}{\tablemathretval}
        \else
            \expandafter\y\tablemath@tmptable{floor(\h)}{\xh}
            \expandafter\y\tablemath@tmptable{floor(\h+1)}{\xhn}
            \pgfmathsetmacro{\tablemathretval}{\xh+(\h-floor(\h))*(\xhn-\xh)}
        \fi
    \or%6
        \pgfmathsetmacro{\h}{(\tablemath@rows+1)*\tablemath@quantile@p}
        \pgfmathparse{int(floor(\h))}
        \ifnum\pgfmathresult=0
            \expandafter\y\tablemath@tmptable{1}{\tablemathretval}
        \else
            \expandafter\y\tablemath@tmptable{floor(\h)}{\xh}
            \expandafter\y\tablemath@tmptable{floor(\h+1)}{\xhn}
            \pgfmathsetmacro{\tablemathretval}{\xh+(\h-floor(\h))*(\xhn-\xh)}
        \fi
    \or%7
        \pgfmathsetmacro{\h}{(\tablemath@rows-1)*\tablemath@quantile@p+1}
        \expandafter\y\tablemath@tmptable{floor(\h)}{\xh}
        \expandafter\y\tablemath@tmptable{floor(\h+1)}{\xhn}
        \pgfmathsetmacro{\tablemathretval}{\xh+(\h-floor(\h))*(\xhn-\xh)}
    \or%8
        \pgfmathsetmacro{\h}{(\tablemath@rows+1/3)*\tablemath@quantile@p+1/3}
        \expandafter\y\tablemath@tmptable{floor(\h)}{\xh}
        \expandafter\y\tablemath@tmptable{floor(\h+1)}{\xhn}
        \pgfmathsetmacro{\tablemathretval}{\xh+(\h-floor(\h))*(\xhn-\xh)}
    \or%9
        \pgfmathsetmacro{\h}{(\tablemath@rows+1/4)*\tablemath@quantile@p+3/8}
        \expandafter\y\tablemath@tmptable{floor(\h)}{\xh}
        \expandafter\y\tablemath@tmptable{floor(\h+1)}{\xhn}
        \pgfmathsetmacro{\tablemathretval}{\xh+(\h-floor(\h))*(\xhn-\xh)}
    \else%
        \pgferror{Quantile method \tablemath@quantile@method invalid. Valid methods are 1-9}
    \fi
    \iftablemath@printresult\tablemathretval\fi
}

%Usable macros:
% \rows
% \cell
% \acc
\newcommand{\tablemathFun}[2][]{%
    \pgfkeys{/tablemath/fun, #1}
    \iftablemath@usefpu\pgfkeys{/pgf/fpu}\fi
    \pgfplotstablegetrowsof{#2}
    \pgfmathsetmacro{\rows}{\pgfplotsretval}
    \pgfplotstableforeachcolumnelement{\tablemath@column}\of#2\as\cell{
        \pgfmathsetmacro{\acc}{\tablemath@fun@code}
    }
    \pgfmathsetmacro{\tablemathretval}{\tablemath@fun@postcode}
    \iftablemath@usefpu
        \iftablemath@printresult\pgfmathprintnumber\tablemathretval\fi
    \else
        \iftablemath@printresult\tablemathretval\fi
    \fi
}

\newcommand{\tablemath@newfun}[1]{%
    \expandafter\newcommand\csname tablemath#1\endcsname[2][]{%
        \pgfkeys{/tablemath, ##1}
        \ifcsname tablemath@results@\tablemath@cmdname##2@#1@\tablemath@column\endcsname
        \else
            \tablemath@parseSorted{##2}
        \fi
        \pgfmathsetmacro{\tablemathretval}{\csname tablemath@results@\tablemath@cmdname##2@#1@\tablemath@column\endcsname}
        \iftablemath@printresult\pgfmathprintnumber\tablemathretval\fi
    }
}

\newcommand\tablemathMedian[2][]{\tablemathQuantile[#1,median]{#2}}
\@for\i:=Min,Max\do{%
    \expandafter\tablemath@newfun\expandafter{\i}
}

\endinput
